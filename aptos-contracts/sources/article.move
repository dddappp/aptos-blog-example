// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module aptos_blog_demo::article {
    use std::option;
    use aptos_blog_demo::comment::{Self, Comment};
    use aptos_blog_demo::genesis_account;
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_std::table_with_length::{Self, TableWithLength};
    use std::string::String;
    use aptos_framework::object;
    use aptos_blog_demo::pass_object;
    friend aptos_blog_demo::article_create_logic;
    friend aptos_blog_demo::article_update_logic;
    friend aptos_blog_demo::article_delete_logic;
    friend aptos_blog_demo::article_add_comment_logic;
    friend aptos_blog_demo::article_update_comment_logic;
    friend aptos_blog_demo::article_remove_comment_logic;
    friend aptos_blog_demo::article_aggregate;

    const EIdAlreadyExists: u64 = 101;
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const ENotInitialized: u64 = 110;
    const EIdNotFound: u64 = 111;

    struct Events has key {
        article_created_handle: event::EventHandle<ArticleCreated>,
        article_updated_handle: event::EventHandle<ArticleUpdated>,
        article_deleted_handle: event::EventHandle<ArticleDeleted>,
        comment_added_handle: event::EventHandle<CommentAdded>,
        comment_updated_handle: event::EventHandle<CommentUpdated>,
        comment_removed_handle: event::EventHandle<CommentRemoved>,
        comment_table_item_added_handle: event::EventHandle<CommentTableItemAdded>,
    }

    struct CommentTableItemAdded has store, drop {
        article_id: address,
        comment_seq_id: u64,
    }

    fun emit_comment_table_item_added(table_item_added: CommentTableItemAdded) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.comment_table_item_added_handle, table_item_added);
    }

    public fun initialize(account: &signer) {
        genesis_account::assert_genesis_account(account);

        let res_account = genesis_account::resource_account_signer();
        move_to(&res_account, Events {
            article_created_handle: account::new_event_handle<ArticleCreated>(&res_account),
            article_updated_handle: account::new_event_handle<ArticleUpdated>(&res_account),
            article_deleted_handle: account::new_event_handle<ArticleDeleted>(&res_account),
            comment_added_handle: account::new_event_handle<CommentAdded>(&res_account),
            comment_updated_handle: account::new_event_handle<CommentUpdated>(&res_account),
            comment_removed_handle: account::new_event_handle<CommentRemoved>(&res_account),
            comment_table_item_added_handle: account::new_event_handle<CommentTableItemAdded>(&res_account),
        });

    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Article has key {
        version: u64,
        title: String,
        body: String,
        owner: address,
        comments: TableWithLength<u64, Comment>,
        comment_seq_id_generator: CommentSeqIdGenerator,
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ObjectController has key {
        extend_ref: object::ExtendRef,
        delete_ref: object::DeleteRef,
        transfer_ref: object::TransferRef,
    }


    public(friend) fun save_object_controller(
        object_signer: &signer,
        extend_ref: object::ExtendRef,
        delete_ref: object::DeleteRef,
        transfer_ref: object::TransferRef,
    ) {
        move_to(
            object_signer,
            ObjectController {
                extend_ref,
                delete_ref,
                transfer_ref
            }
        )
    }

    struct CommentSeqIdGenerator has store {
        sequence: u64,
    }

    public(friend) fun current_comment_seq_id(article: &Article): u64 {
        article.comment_seq_id_generator.sequence
    }

    public(friend) fun next_comment_seq_id(article: &mut Article): u64 {
        article.comment_seq_id_generator.sequence = article.comment_seq_id_generator.sequence + 1;
        article.comment_seq_id_generator.sequence
    }

    public fun version(article: &Article): u64 {
        article.version
    }

    public fun title(article: &Article): String {
        article.title
    }

    public(friend) fun set_title(article: &mut Article, title: String) {
        assert!(std::string::length(&title) <= 200, EDataTooLong);
        article.title = title;
    }

    public fun body(article: &Article): String {
        article.body
    }

    public(friend) fun set_body(article: &mut Article, body: String) {
        assert!(std::string::length(&body) <= 2000, EDataTooLong);
        article.body = body;
    }

    public fun owner(article: &Article): address {
        article.owner
    }

    public(friend) fun set_owner(article: &mut Article, owner: address) {
        article.owner = owner;
    }

    public(friend) fun add_comment(id: address, article: &mut Article, comment: Comment) acquires Events {
        let comment_seq_id = comment::comment_seq_id(&comment);
        assert!(!table_with_length::contains(&article.comments, comment_seq_id), EIdAlreadyExists);
        table_with_length::add(&mut article.comments, comment_seq_id, comment);
        emit_comment_table_item_added(CommentTableItemAdded {
            article_id: id,
            comment_seq_id,
        });
    }

    public(friend) fun remove_comment(article: &mut Article, comment_seq_id: u64) {
        assert!(table_with_length::contains(&article.comments, comment_seq_id), EIdNotFound);
        let comment = table_with_length::remove(&mut article.comments, comment_seq_id);
        comment::drop_comment(comment);
    }

    public(friend) fun borrow_mut_comment(article: &mut Article, comment_seq_id: u64): &mut Comment {
        table_with_length::borrow_mut(&mut article.comments, comment_seq_id)
    }

    public fun borrow_comment(article: &Article, comment_seq_id: u64): &Comment {
        table_with_length::borrow(&article.comments, comment_seq_id)
    }

    public fun comments_contains(article: &Article, comment_seq_id: u64): bool {
        table_with_length::contains(&article.comments, comment_seq_id)
    }

    public fun comments_length(article: &Article): u64 {
        table_with_length::length(&article.comments)
    }

    public(friend) fun new_article(
        title: String,
        body: String,
        owner: address,
    ): Article {
        assert!(std::string::length(&title) <= 200, EDataTooLong);
        assert!(std::string::length(&body) <= 2000, EDataTooLong);
        Article {
            version: 0,
            title,
            body,
            owner,
            comments: table_with_length::new<u64, Comment>(),
            comment_seq_id_generator: CommentSeqIdGenerator { sequence: 0, },
        }
    }

    struct ArticleCreated has store, drop {
        id: option::Option<address>,
        title: String,
        body: String,
        owner: address,
    }

    public fun article_created_id(article_created: &ArticleCreated): option::Option<address> {
        article_created.id
    }

    public fun set_article_created_id(article_created: &mut ArticleCreated, id: address) {
        article_created.id = option::some(id);
    }

    public fun article_created_title(article_created: &ArticleCreated): String {
        article_created.title
    }

    public fun article_created_body(article_created: &ArticleCreated): String {
        article_created.body
    }

    public fun article_created_owner(article_created: &ArticleCreated): address {
        article_created.owner
    }

    public(friend) fun new_article_created(
        title: String,
        body: String,
        owner: address,
    ): ArticleCreated {
        ArticleCreated {
            id: option::none(),
            title,
            body,
            owner,
        }
    }

    struct ArticleUpdated has store, drop {
        id: address,
        version: u64,
        title: String,
        body: String,
        owner: address,
    }

    public fun article_updated_id(article_updated: &ArticleUpdated): address {
        article_updated.id
    }

    public fun article_updated_title(article_updated: &ArticleUpdated): String {
        article_updated.title
    }

    public fun article_updated_body(article_updated: &ArticleUpdated): String {
        article_updated.body
    }

    public fun article_updated_owner(article_updated: &ArticleUpdated): address {
        article_updated.owner
    }

    public(friend) fun new_article_updated(
        id: address,
        article: &Article,
        title: String,
        body: String,
        owner: address,
    ): ArticleUpdated {
        ArticleUpdated {
            id,
            version: version(article),
            title,
            body,
            owner,
        }
    }

    struct ArticleDeleted has store, drop {
        id: address,
        version: u64,
    }

    public fun article_deleted_id(article_deleted: &ArticleDeleted): address {
        article_deleted.id
    }

    public(friend) fun new_article_deleted(
        id: address,
        article: &Article,
    ): ArticleDeleted {
        ArticleDeleted {
            id,
            version: version(article),
        }
    }

    struct CommentAdded has store, drop {
        id: address,
        version: u64,
        comment_seq_id: u64,
        commenter: String,
        body: String,
        owner: address,
    }

    public fun comment_added_id(comment_added: &CommentAdded): address {
        comment_added.id
    }

    public fun comment_added_comment_seq_id(comment_added: &CommentAdded): u64 {
        comment_added.comment_seq_id
    }

    public fun comment_added_commenter(comment_added: &CommentAdded): String {
        comment_added.commenter
    }

    public fun comment_added_body(comment_added: &CommentAdded): String {
        comment_added.body
    }

    public fun comment_added_owner(comment_added: &CommentAdded): address {
        comment_added.owner
    }

    public(friend) fun new_comment_added(
        id: address,
        article: &Article,
        comment_seq_id: u64,
        commenter: String,
        body: String,
        owner: address,
    ): CommentAdded {
        CommentAdded {
            id,
            version: version(article),
            comment_seq_id,
            commenter,
            body,
            owner,
        }
    }

    struct CommentUpdated has store, drop {
        id: address,
        version: u64,
        comment_seq_id: u64,
        commenter: String,
        body: String,
        owner: address,
    }

    public fun comment_updated_id(comment_updated: &CommentUpdated): address {
        comment_updated.id
    }

    public fun comment_updated_comment_seq_id(comment_updated: &CommentUpdated): u64 {
        comment_updated.comment_seq_id
    }

    public fun comment_updated_commenter(comment_updated: &CommentUpdated): String {
        comment_updated.commenter
    }

    public fun comment_updated_body(comment_updated: &CommentUpdated): String {
        comment_updated.body
    }

    public fun comment_updated_owner(comment_updated: &CommentUpdated): address {
        comment_updated.owner
    }

    public(friend) fun new_comment_updated(
        id: address,
        article: &Article,
        comment_seq_id: u64,
        commenter: String,
        body: String,
        owner: address,
    ): CommentUpdated {
        CommentUpdated {
            id,
            version: version(article),
            comment_seq_id,
            commenter,
            body,
            owner,
        }
    }

    struct CommentRemoved has store, drop {
        id: address,
        version: u64,
        comment_seq_id: u64,
    }

    public fun comment_removed_id(comment_removed: &CommentRemoved): address {
        comment_removed.id
    }

    public fun comment_removed_comment_seq_id(comment_removed: &CommentRemoved): u64 {
        comment_removed.comment_seq_id
    }

    public(friend) fun new_comment_removed(
        id: address,
        article: &Article,
        comment_seq_id: u64,
    ): CommentRemoved {
        CommentRemoved {
            id,
            version: version(article),
            comment_seq_id,
        }
    }

    public(friend) fun update_version_and_add(id: address, article: Article) acquires ObjectController {
        article.version = article.version + 1;
        let extend_ref = &borrow_global<ObjectController>(id).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        add_article(&object_signer, article)
    }

    public(friend) fun add_article(object_signer: &signer, article: Article) {
        move_to(object_signer, article);
    }

    public(friend) fun remove_article(id: address): Article acquires Article {
        move_from<Article>(id)
    }

    public(friend) fun delete_article(id: address) acquires ObjectController {
        let ObjectController {
            extend_ref: _extend_ref,
            delete_ref,
            transfer_ref: _transfer_ref,
        } = move_from<ObjectController>(
            id
        );
        object::delete(delete_ref)
    }

    public fun get_article(id: address): pass_object::PassObject<Article> acquires Article {
        let article = remove_article(id);
        pass_object::new(article)
    }

    public fun return_article(object_signer: &signer, article_pass_obj: pass_object::PassObject<Article>) {
        let article = pass_object::extract(article_pass_obj);
        add_article(object_signer, article);
    }

    public(friend) fun drop_article(article: Article) {
        let Article {
            version: _version,
            title: _title,
            body: _body,
            owner: _owner,
            comments,
            comment_seq_id_generator,
        } = article;
        let CommentSeqIdGenerator {
            sequence: _,
        } = comment_seq_id_generator;
        table_with_length::destroy_empty(comments);
    }

    public(friend) fun emit_article_created(article_created: ArticleCreated) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.article_created_handle, article_created);
    }

    public(friend) fun emit_article_updated(article_updated: ArticleUpdated) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.article_updated_handle, article_updated);
    }

    public(friend) fun emit_article_deleted(article_deleted: ArticleDeleted) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.article_deleted_handle, article_deleted);
    }

    public(friend) fun emit_comment_added(comment_added: CommentAdded) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.comment_added_handle, comment_added);
    }

    public(friend) fun emit_comment_updated(comment_updated: CommentUpdated) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.comment_updated_handle, comment_updated);
    }

    public(friend) fun emit_comment_removed(comment_removed: CommentRemoved) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.comment_removed_handle, comment_removed);
    }

}
